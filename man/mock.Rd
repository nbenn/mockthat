% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mock.R
\name{with_mock}
\alias{with_mock}
\alias{local_mock}
\alias{mock}
\alias{mock_call}
\alias{mock_args}
\alias{mock_arg}
\alias{mock_n_called}
\title{Mock functions in a package.}
\usage{
with_mock(..., mock_env = pkg_env(), eval_env = parent.frame())

local_mock(
  ...,
  mock_env = pkg_env(),
  eval_env = parent.frame(),
  local_env = eval_env
)

mock(expr, env = parent.frame())

mock_call(x, call_no = mock_n_called(x))

mock_args(x, call_no = mock_n_called(x))

mock_arg(x, arg, call_no = mock_n_called(x))

mock_n_called(x)
}
\arguments{
\item{...}{Named parameters redefine mocked functions, unnamed parameters
will be evaluated after mocking the functions.}

\item{mock_env}{The environment in which to patch the functions,
defaults to the top-level environment. A string is interpreted as package
name.}

\item{eval_env}{Environment in which expressions passed as \code{...} are
evaluated, defaults to \code{\link[=parent.frame]{parent.frame()}}.}

\item{local_env}{Passed to \code{\link[withr:defer]{withr::defer()}} as \code{envir} argument}

\item{expr}{Expression to be used as body of the function to be mocked.}

\item{env}{Environment used as ancestor to the mock function environment.}

\item{x}{Object of class \code{mock_fun} to be queried for call and argument
information.}

\item{call_no}{The call number of interest (in case the function was called
multiple times).}

\item{arg}{String-valued argument name to be retrieved.}
}
\value{
\itemize{
\item \code{local_mock()}: the result of the last unnamed argument passed as \code{...}
(evaluated in the environment passed as \code{eval_env})
\item \code{local_mock()}: a list of functions or \code{mock_fun} objects (invisibly)
\item \code{mock()}: a \code{mock_fun} object
\item \code{mock_call()}: a call (created by \code{\link[base:match.call]{base::match.call()}})
\item \code{mock_arg()}: the object used as specified function argument
\item \code{mock_args()}: a list of all function arguments used to create a call to
the \code{mock_fun} object in question
\item \code{mock_n_called()}: a scalar integer
}
}
\description{
Mocking allows you to temporary replace the implementation of functions
within a package, which useful for testing code that relies on functions
that are slow, have unintended side effects or access resources that may
not be available when testing.

Up until recently, such capability was offered via \code{\link[testthat:with_mock]{testthat::with_mock()}},
but with release of version 3.0.0 and introduction of edition 3, this was
deprecated from 'testthat', leaving it to third party packages to replace
this feature. Powered by \code{\link[utils:getFromNamespace]{utils::assignInNamespace()}}, this mocking
implementation can be used to stub out both exported and non-exported
functions from a package, as well as functions explicitly imported from
other packages using either \code{importFrom} directives or namespaced function
calls using \code{::}.
}
\details{
Borrowing the API from the now-deprecated \code{\link[testthat:with_mock]{testthat::with_mock()}}, named
arguments passed as \code{...} are used to define functions to be mocked, where
names specify the target functions and the arguments themselves are used as
replacement functions. Unnamed arguments passed as \code{...} will be evaluated
in the environment specified as \code{eval_env} using the mocked functions. On
exit of \code{with_mock()}, the mocked functions are reverted to their original
state.

Replacement functions can either be specified as complete functions, or as
either quoted expressions, subsequently used as function body or objects
used as return values. If functions are created from return values or
complete function bodies, they inherit the signatures from the respective
functions they are used to mock, alongside the ability to keep track of
how they are subsequently called. A constructor for such mock-objects is
available as \code{mock()}, which quotes the expression passed as \code{expr}.

If mocking is desirable for multiple separate calls to the function being
tested, \code{local_mock()} is available, which holds onto the mocked state for
the lifetime of the environment passed as \code{local_env} using
\code{\link[withr:defer]{withr::defer()}}. Unlike \code{with_mock()}, which returns the result of
evaluating the last unnamed argument passed as \code{...}, \code{local_mock()}
(invisibly) returns the functions used for mocking, which if not fully
specified as functions, will be mock-objects described in the previous
paragraph.

Calls to mock-objects either constructed using \code{mock()} or returned by
\code{local_mock()} can keep track of how they were called and functions
\code{mock_call()}, \code{mock_args()} and \code{mock_n_called()} can be used to retrieve
related information:
\itemize{
\item \code{mock_call()}: retrieves the call captured by \code{\link[base:match.call]{base::match.call()}}
\item \code{mock_arg()}: retrieves the value of the argument with name passed as
string-valued argument \code{arg}
\item \code{mock_args()}: retrieves a list of all arguments used for calling the
mocked function
\item \code{mock_n_called()}: counts the number of times the mocked function was
called
}

Calls to mock objects are indexed chronologically and both \code{mock_call()}
and \code{mock_args()} provide an argument \code{call_no} which can be used to specify
which call is of interest, with the default being the most recent (or last)
one.
}
\examples{

url <- "https://eu.httpbin.org/get?foo=123"
mok <- function(...) "mocked request"

with_mock(
  `curl::curl_fetch_memory` = mok,
  curl::curl_fetch_memory(url)
)

dl_fun <- function(x) curl::curl_fetch_memory(x)

with_mock(
  `curl::curl_fetch_memory` = mok,
  dl_fun(url)
)

json <- function(...) '["mocked request"]'

with_mock(
  `curl::curl` = json,
  jsonlite::fromJSON(url)
)

with_mock(
  `curl::curl` = '["mocked request"]',
  jsonlite::fromJSON(url)
)

with_mock(
  `curl::curl` = quote({
    x <- "mocked request"
    paste0('["', x, '"]')
  }),
  jsonlite::fromJSON(url)
)

with_mock(
  `curl::curl` = json,
  parse_and_simplify = function(txt, ...) gsub('\\\\[?\\\\"\\\\]?', "", txt),
  jsonlite::fromJSON(url),
  mock_env = "jsonlite"
)

mk <- mock("mocked request")
dl <- function(x) curl::curl(x)

with_mock(`curl::curl` = mk, dl(url))

mock_call(mk)
mock_args(mk)

local({
  mk <- local_mock(`curl::curl` = "mocked request")
  list(dl(url), mock_arg(mk, "url"))
})

}
